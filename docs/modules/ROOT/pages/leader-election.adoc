[[leader-election]]
= Leader Election

To include leader election in your project, add the following dependency.
[source,xml]
----
<dependency>
	<groupId>org.springframework.cloud</groupId>
	<artifactId>spring-cloud-kubernetes-fabric8-leader-election</artifactId>
</dependency>
----

== Leader Election Info Contributor

Spring Cloud Kubernetes Leader Election includes an `InfoContributor` that adds leader election information to
Spring Bootâ€™s `/actuator/info` endpoint. This contributor provides information about the current leader,
including the leader ID, role, and whether the current application instance is the leader.

Example output:
[source,json]
----
{
  "leaderElection": {
    "leaderId": "my-app-pod-1",
    "role": "my-role",
    "isLeader": true
  }
}
----

You can disable this `InfoContributor` by setting `management.info.leader.election.enabled`
to `false` in `application.[properties | yaml]`:

[source,properties]
----
management.info.leader.election.enabled=false
----

To enable or disable leader election globally, you can use the following property:

[source]
----
spring.cloud.kubernetes.leader.election.enabled=true
----

The Spring Cloud Kubernetes leader election mechanism uses a Kubernetes `Lease` when the cluster supports it,
and falls back to a `ConfigMap` otherwise. Even when `Lease` is supported, you can explicitly force the use of
a `ConfigMap` via configuration:

[source]
----
spring.cloud.kubernetes.leader.election.use-config-map-as-lock=true
----

The name of the `Lease` or `ConfigMap` can be configured using the following property
(the default value is `spring-k8s-leader-election-lock`):

[source]
----
spring.cloud.kubernetes.leader.election.lockName=other-name
----

The namespace where the lock is created (`default` is used if none is explicitly set)
can also be configured:

[source]
----
spring.cloud.kubernetes.leader.election.lockNamespace=other-namespace
----

Before the leader election process starts, the application can wait until the pod is ready
(via the readiness check). This behavior is enabled by default, but can be disabled if needed:

[source]
----
spring.cloud.kubernetes.leader.election.waitForPodReady=false
----

As with the previous implementation, leader election events are published by default,
but this behavior can be disabled:

[source]
----
spring.cloud.kubernetes.leader.election.publishEvents=false
----

Several parameters control how the leader election process operates. At a high level,
all candidate pods attempt to become the leader by trying to _acquire_ the lock. If the lock
is already held, they will retry acquisition every
`spring.cloud.kubernetes.leader.election.retryPeriod`
(specified as a `java.time.Duration`, with a default of 2 seconds).

If the lock is not held, the current pod becomes the leader by writing a "record" into the lock
(`Lease` or `ConfigMap`). Among other fields, this record contains `leaseDuration`
(configured via `spring.cloud.kubernetes.leader.election.leaseDuration`, defaulting to 15 seconds,
type `java.time.Duration`). This value acts as a TTL for the lock: no other pod can acquire it
until this duration has expired since the last renewal.

Once a pod becomes the leader, it periodically (every `retryPeriod`) attempts to renew its
leadership. On each successful renewal, the record stored in the lock is updated, including the
`renewTime` field. These values can be inspected using tools such as
`kubectl describe lease ...`.

Renewal must occur within the interval specified by
`spring.cloud.kubernetes.leader.election.renewDeadline`
(default 10 seconds). If the leader fails to renew within this interval, it loses leadership
and a new leader election cycle begins. Because follower pods attempt acquisition every
`retryPeriod`, the same pod may immediately regain leadership.

To give other pods a better chance of becoming leader after a renewal failure, you can configure
the following property (specified as a `Duration`, defaulting to 3 seconds):

[source]
----
spring.cloud.kubernetes.leader.election.wait-after-renewal-failure=3s
----

This setting causes a pod that lost leadership due to a renewal failure to wait before attempting
to reacquire leadership.

A pod can lose leadership in three ways:

- During a graceful application shutdown, in which case all leader election resources are cleaned up.

- When leadership is voluntarily relinquished without an exception; in this case, the pod will attempt to acquire leadership again.

- When an exception occurs during leadership. If

[source]
----
spring.cloud.kubernetes.leader.election.restart-on-failure
----

is set to `true`, the pod will attempt to rejoin the leader election process. Otherwise, the
exception is logged and the pod will not participate in leader election again.

To illustrate these settings, consider two pods participating in leader election: `podA` and
`podB`. Both start at `12:00:00`, and `podA` becomes the leader. Every two seconds (`retryPeriod`),
`podB` attempts to acquire leadership by checking the state of the lock.

After `podA` becomes the leader, it renews its leadership every two seconds by updating the lock
record. The time between the last successful renewal and the next must not exceed the
`renewDeadline` (10 seconds by default). If `podA` fails to renew within this window (for example,
due to a long GC pause or a connectivity issue), it loses leadership and `podB` can acquire it.
If leadership is relinquished gracefully, the lock is cleared and `podB` can acquire leadership
immediately.

A different scenario occurs if `podA` terminates abruptly (for example, due to an OOM kill)
without clearing the lock. Suppose `podA` renews leadership at `12:00:04` and is killed at
`12:00:05`. At `12:00:06`, `podB` attempts to acquire leadership and checks whether the current
time is after the last renewal plus the `leaseDuration`:

[source]
----
12:00:06 > (12:00:04 + 00:00:15)
----

This condition is false, so leadership cannot be acquired. The same check will fail until the
lease expires, at which point `podB` can acquire leadership. A lower `leaseDuration` therefore
results in faster leadership takeover after abrupt failures.

You may need to configure appropriate RBAC permissions to use leader election, for example:

[source]
----
 - apiGroups: [ "coordination.k8s.io" ]
   resources: [ "leases" ]
   resourceNames: [ "spring-k8s-leader-election-lock" ]
   verbs: [ "get", "update", "create" ]
 - apiGroups: [ "" ]
   resources: [ "configmaps" ]
   resourceNames: [ "spring-k8s-leader-election-lock" ]
   verbs: [ "get", "update", "create" ]
----
